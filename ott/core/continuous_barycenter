# coding=utf-8
# Copyright 2022 Google LLC.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Lint as: python3
"""A Jax version of the W barycenter algorithm (Cuturi Doucet 2014)."""
import functools
from typing import Any, Dict, NamedTuple, Optional, Union, Int

import jax
import jax.numpy as jnp
from ott.core import fixed_point_loop
from ott.core import problems
from ott.core import bar_problems
from ott.core import sinkhorn
from ott.core import sinkhorn_lr
from ott.core import gromov_wasserstein
from ott.geometry import epsilon_scheduler
from ott.geometry import geometry
from ott.geometry import costs
from ott.geometry import low_rank
from ott.geometry import pointcloud


class BarycenterOutput(NamedTuple):
  """Holds the output of a Wasserstein Barycenter solver.

  The goal is to approximate the W barycenter of a set of N measures using
  a discrete measure described by k locations x. To do so the OT between
  each of the input N measures to the barycenter is recomputed and x_bar
  adjusted following that result.

  Attributes:
    costs: Holds the sequence of weighted sum of N regularized W costs seen
      (possibly debiased) through the outer loop of the solver.
    linear_convergence: Holds the sequence of bool convergence flags of the
      inner N Sinkhorn iterations.
    convergence: Bool convergence flag for the outer Barycenter iterations.
    errors: Holds sequence of matrices of N x max_iterations errors of the
      N Sinkhorn algorithms run at each inner iteration.
    x : barycenter locations, k x dimension
    a : weights of the barycenter
    transports: final N transport objects mapping barycenter to input measures.
    reg_gw_cost: Total regularized optimal transport cost upon convergence
  """
  costs: Optional[jnp.ndarray] = None
  linear_convergence: Optional[jnp.ndarray] = None
  convergence: bool = False
  errors: Optional[jnp.ndarray] = None
  x = None
  a = None
  transports = None
  reg_gw_cost = None
  
  def set(self, **kwargs) -> 'BarycenterOutput':
    """Returns a copy of self, possibly with overwrites."""
    return self._replace(**kwargs)


class BarycenterState(NamedTuple):
  """Holds the state of the Wasserstein barycenter solver.

  Attributes:
    costs: Holds the sequence of regularized GW costs seen through the outer
      loop of the solver.
    linear_convergence: Holds the sequence of bool convergence flags of the
      inner Sinkhorn iterations.
    errors: Holds sequence of vectors of errors of the Sinkhorn algorithm
      at each iteration.
    linear_states: State used to solve and store solutions to the OT problems
      from the barycenter to the measures.
    x: barycenter points
    a: barycenter weights
  """
  costs: Optional[jnp.ndarray] = None
  linear_convergence: Optional[jnp.ndarray] = None
  errors: Optional[jnp.ndarray] = None
  x: Optional[jnp.ndarray] = None
  a: Optional[jnp.ndarray] = None

  def set(self, **kwargs) -> 'BarycenterState':
    """Returns a copy of self, possibly with overwrites."""
    return self._replace(**kwargs)
  
  def update(self, iteration: int, 
            bar_prob: bar_problems.BarycenterProblem, 
            linear_ot_solver: Any, 
            store_errors: bool):
    
    out = solve_linear_ot(self.a, self.x,
      bar_prob.segmented_b, bar_prob.segmented_y, bar_prob.cost_fn, bar_prob.epsilon, linear_ot_solver,store_errors)
    cost = jnp.average(out[0], weights= bar_prob.weights)
    costs = self.costs.at[iteration].set(cost)
    errors = None
    linear_convergence = jnp.all(out[1])
    if store_errors and self.errors is not None:
      errors = self.errors.at[iteration, :, :].set(out.errors)

    x_new = jnp.average(
      barycentric_projection(out[2], bar_prob.segmented_y, bar_prob.cost_fn),
      weights = bar_prob.weights, axis=0)
    return self.set(costs=costs,
                    linear_convergence=linear_convergence,
                    errors=errors,
                    x=x_new)

@functools.partial(jax.vmap, in_axes=[2,3])
def barycentric_projection(matrix, y, cost_fn):
  return jax.vmap(cost_fn.barycenter, in_axes=[0,0, None])(matrix, y, cost_fn)


@functools.partial(jax.vmap, in_axes=[2,3])
def solve_linear_ot(a, x, b, y, cost_fn, epsilon, solver, return_errors):
  out = solver(
      problems.LinearProblem(
        pointcloud.PointCloud(x, y, cost_fn = cost_fn, epsilon= epsilon),
        a, b))
  
  return (out.reg_ot_cost, out.converged, 
  out.matrix, out.errors if return_errors else None)


@jax.tree_util.register_pytree_node_class
class WassersteinBarycenter(gromov_wasserstein.GromovWasserstein):
  """A Continuous Wasserstein barycenter solver. Uses similar loop as GW."""

  def __call__(
      self,
      bar_prob: bar_problems.BarycenterProblem,
      bar_size: int = 100,
      x_init: jnp.ndarray = None,
      debiased : bool = False,
      rng: Int = 0
      ) -> BarycenterState:    
    iterations_fn = functools.partial(iterations, rank=self.rank)
    bar_fn = jax.jit(iterations_fn) if self.jit else iterations_fn
    out = bar_fn(self, bar_size, bar_prob, x_init, debiased, rng) 
    iteration = jnp.sum(out.costs != 0)
    convergence = jnp.logical_not(self.not_converged(out, iteration))
    return out

  def init_state(self, bar_prob, bar_size, x_init, rng
  ) -> BarycenterState:
    """Initializes the state of the Wasserstein barycenter iterations."""
    if x_init is not None:
      assert bar_size == x_init.shape[0]
      x = x_init
    else:
      # sample randomly points in the support of the y measures
      indices_subset = jax.random.choice(jax.random.PRNGKey(rng), 
        a=bar_prob.flattened_y.shape[0],
        shape=bar_size,
        replace=False,
        p=bar_prob.flattened_b)
      x = bar_prob.flattened_y[indices_subset,:]
    
    # Only handle uniform weights for barycenter for now.
    a = jnp.ones((bar_size,))/ bar_size
    num_iter = self.max_iterations
    if self.store_inner_errors:
      errors = -jnp.ones(
        (self.num_iter, bar_prob.num_segments,
        self.linear_ot_solver.outer_iterations))
    else:
      errors = None
    return BarycenterState(-jnp.ones((num_iter,)), -jnp.ones((num_iter,)),
                   errors, x, a)

  def output_from_state(self, state):    
    return state


def iterations(solver: WassersteinBarycenter,
               bar_size, bar_prob, x_init, rng, debiased
               ) -> WassersteinBarycenter:
  """A jittable Wasserstein barycenter outer loop."""

  def cond_fn(iteration, constants, state):
    solver = constants
    return solver.not_converged(state, iteration)

  def body_fn(iteration, constants, state, compute_error):
    del compute_error  # Always assumed True
    solver, debiased = constants    
    return state.update(
        iteration,
        
        solver.store_inner_errors)

  state = fixed_point_loop.fixpoint_iter(
      cond_fn=cond_fn,
      body_fn=body_fn,
      min_iterations=solver.min_iterations,
      max_iterations=solver.max_iterations,
      inner_iterations=1,
      constants=(solver, debiased),
      state=solver.init_state(bar_prob, bar_size, x_init, rng))

  return solver.output_from_state(state)


# def make(
#     epsilon: Union[epsilon_scheduler.Epsilon, float] = 1.,
#     rank: int = -1,
#     max_iterations: int = 50,
#     jit: bool = False,
#     warm_start: bool = True,
#     store_inner_errors: bool = False,
#     linear_ot_solver_kwargs: Optional[Dict[str, Any]] = None,
#     threshold: float = 1e-2,
#     min_iterations: int = 1,
#     **kwargs) -> GromovWasserstein:
#   """Creates a GromovWasserstein solver.

#   Args:
#     epsilon: a regularization parameter or a epsilon_scheduler.Epsilon object.
#     rank: integer used to constrain the rank of GW solutions if >0.
#     max_iterations: int32, the maximum number of outer iterations for
#       Gromov Wasserstein.
#     jit: bool, if True, jits the function.
#     warm_start: deprecated.
#     store_inner_errors: whether or not to return all the errors of the inner
#       Sinkhorn iterations.
#     linear_ot_solver_kwargs: Optionally a dictionary containing the keywords
#       arguments for the linear OT solver (e.g. sinkhorn)
#     threshold: threshold (progress between two iterate costs) used to stop GW.
#     min_iterations: see fixed_point_loop.
#     **kwargs: additional kwargs for epsilon.

#   Returns:
#     A GromovWasserstein solver.
#   """
#   del warm_start
#   if linear_ot_solver_kwargs is None:
#     linear_ot_solver_kwargs = {}

#   if rank == -1:
#     sink = sinkhorn.make(**linear_ot_solver_kwargs)
#   elif rank > 0:
#     # `rank` and `epsilon` are arguments of the `sinkhorn_lr` solver. As we are
#     # passing them to make, we should not pass them in `linear_ot_solver_kwargs`
#     # Therefore, the `rank` or `epsilon` passed to `linear_ot_solver_kwargs` are
#     # deleted.
#     linear_ot_solver_kwargs.pop('rank', None)
#     linear_ot_solver_kwargs.pop('epsilon', None)
#     sink = sinkhorn_lr.make(
#         rank=rank, epsilon=epsilon, **linear_ot_solver_kwargs)

#   return GromovWasserstein(
#       epsilon, rank, max_iterations=max_iterations,
#       jit=jit, linear_ot_solver=sink, threshold=threshold,
#       store_inner_errors=store_inner_errors,
#       min_iterations=min_iterations, **kwargs)


# def gromov_wasserstein(
#     geom_xx: geometry.Geometry,
#     geom_yy: geometry.Geometry,
#     geom_xy: Optional[geometry.Geometry] = None,
#     fused_penalty: Optional[float] = None,
#     a: Optional[jnp.ndarray] = None,
#     b: Optional[jnp.ndarray] = None,
#     loss: Optional[str] = None,
#     tau_a: Optional[float] = 1.0,
#     tau_b: Optional[float] = 1.0,
#     gw_unbalanced_correction: bool = True,
#     **kwargs) -> GWOutput:
#   """Wrapper to solve a Gromov Wasserstein problem.

#   Wrapper that instantiates a quadratic problem (possibly with linear term
#   if the problem is fused) and calls a solver to output a solution.

#   Args:
#     geom_xx: a Geometry object for the first view.
#     geom_yy: a second Geometry object for the second view.
#     geom_xy: a Geometry object representing the linear cost in FGW.
#     fused_penalty: multiplier of the linear term in Fused Gromov Wasserstein,
#       i.e. loss = quadratic_loss + fused_penalty * linear_loss. If geom_xy is
#       None fused_penalty will be ignored, i.e. fused_penalty = 0
#     a: jnp.ndarray<float>[num_a,] or jnp.ndarray<float>[batch,num_a] weights.
#     b: jnp.ndarray<float>[num_b,] or jnp.ndarray<float>[batch,num_b] weights.
#     loss: str, None defaults to the square Euclidean distance, can also
#       receive 'kl' to define the GW loss.
#     tau_a: float between 0 and 1.0, parameter that controls the strength of the
#       KL divergence constraint between the weights and marginals of the
#       transport for the first view. If set to 1.0, then it is equivalent to a
#       hard constraint and if smaller to a softer constraint.
#     tau_b: float between 0 and 1.0, parameter that controls the strength of the
#       KL divergence constraint between the weights and marginals of the
#       transport for the second view. If set to 1.0, then it is equivalent to a
#       hard constraint and if smaller to a softer constraint.
#     gw_unbalanced_correction: True (default) if the unbalanced version of
#       Sejourne et al (Neurips 2021) is used, False if tau_a and tau_b
#       only affect the inner Sinhkorn loop.
#     **kwargs: keyword arguments to make.

#   Returns:
#     A GromovWassersteinState named tuple.
#   """
#   losses = {'kl': quad_problems.make_kl_loss}
#   loss_fn = losses.get(loss, None)
#   prob = quad_problems.QuadraticProblem(
#       geom_xx,
#       geom_yy,
#       geom_xy=geom_xy,
#       fused_penalty=fused_penalty,
#       a=a,
#       b=b,
#       loss=(loss_fn() if loss_fn is not None else None),
#       tau_a=tau_a,
#       tau_b=tau_b,
#       gw_unbalanced_correction=gw_unbalanced_correction)
#   solver = make(**kwargs)
#   return solver(prob)
